# 栈内存管理



应用程序的内存一般会分成堆区和栈区，程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收，我们在上两节已经详细分析了堆内存的申请和释放过程，本节会介绍 Go 语言栈内存的管理。



## 设计原理

栈区的内存一般由编译器自动分配和释放，**其中存储着函数的入参以及局部变量**，这些参数会随着函数的创建而创建，函数的返回而消亡，一般不会在程序中长期存在，这种线性的内存分配策略有着极高地效率，但是工程师也往往不能控制栈内存的分配，这部分工作基本都是由编译器完成的。



### 寄存器

寄存器[1](https://draven.co/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#fn:1)是中央处理器（CPU）中的稀缺资源，它的存储能力非常有限，但是能提供最快的读写速度，充分利用寄存器的速度可以构建高性能的应用程序。寄存器在物理机上非常有限，然而栈区的操作会使用到两个以上的寄存器，这足以说明栈内存在应用程序的重要性。

栈寄存器是 CPU 寄存器中的一种，它的主要作用是跟踪函数的调用栈[2](https://draven.co/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#fn:2)，Go 语言的汇编代码包含 BP 和 SP 两个栈寄存器，它们分别存储了栈的基址指针和栈顶的地址，栈内存与函数调用的关系非常紧密，我们在函数调用一节中曾经介绍过栈区，BP 和 SP 之间的内存就是当前函数的调用栈。

![stack-registers](栈内存管理.assets/2020-03-23-15849514795843-stack-registers.png)

​												**栈寄存器与内存**

因为历史原因，栈区内存都是从高地址向低地址扩展的，当应用程序申请或者释放栈内存时只需要修改 SP 寄存器的值，这种线性的内存分配方式与堆内存相比更加快速，仅会带来极少的额外开销。



### 线程栈

如果我们在 Linux 操作系统中执行 `pthread_create` 系统调用，进程会启动一个新的线程，如果用户没有通过软资源限制 `RLIMIT_STACK` 指定线程栈的大小，那么操作系统会根据架构选择不同的默认栈大小[3](https://draven.co/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#fn:3)。

| 架构    | 默认栈大小 |
| :------ | ---------: |
| i386    |       2 MB |
| IA-64   |      32 MB |
| PowerPC |       4 MB |
| …       |          … |
| x86_64  |       2 MB |

​											**架构和线程默认栈大小**

多数架构上默认栈大小都在 2 ~ 4 MB 左右，极少数架构会使用 32 MB 的栈，用户程序可以在分配的栈上存储函数参数和局部变量。然而这个固定的栈大小在某些场景下不是合适的值，如果程序需要同时运行几百个甚至上千个线程，这些线程中的大部分都只会用到很少的栈空间，当函数的调用栈非常深时，固定栈大小也无法满足用户程序的需求。

线程和进程都是代码执行的上下文[4](https://draven.co/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#fn:4)，但是如果一个应用程序包含成百上千个执行上下文并且每个上下文都是线程，会占用大量的内存空间并带来其他的额外开销，Go 语言在设计时认为执行上下文是轻量级的，所以它在用户态实现 Goroutine 作为执行上下文。



-------------------------------------------------------------------------------------------------------------------------------------------------------

 **简单理解(方便理解，不一定对)**

- Java 的 Thread（内核线程）：

  - 是一个**完整的、重量级的上下文**
  - 内核知道它的存在
  - 它有独立的线程栈、寄存器、线程 ID、线程局部变量
  - 切换时需要操作系统参与

  Go 的 Goroutine（用户态协程）：

  - 是 Go runtime 自己维护的**轻量上下文**
  - 并没有操作系统中“线程”的完整资源结构
  - 所有“上下文切换”都在用户态完成，只保存**执行现场（寄存器 + 栈 + 调度信息）**

**举个例子：你打断一个函数运行**

Java 线程切换：

- OS 需要保存 CPU 寄存器（IP、SP 等）
- 切换到另一个线程时要恢复另一个线程的上下文
- 如果线程很多，调度压力大

Go 协程切换：

- Go runtime 保存当前函数的程序计数器（PC）和栈指针
- 把它放进调度队列中
- 不用操作系统帮忙切换

 **补充：Goroutine 的调度上下文只包括**

- 当前运行函数的指令位置（PC）
- 栈帧（最初只有 2KB）
- goroutine 的调度状态（runnable、waiting 等）
- 与 M（内核线程）绑定信息

所以 goroutine 能起十万、一百万个不假，因为它“上下文”轻很多。

-------------------------------------------------------------------------------------------------------------------------------------------------------





### 逃逸分析

> **逃逸分析的核心目标是：**
>
> **判断一个变量是否可能在函数外部被引用**（“逃逸”到函数作用域之外），如果是，就把它分配到堆上，否则分配在栈上。

在 C 语言和 C++ 这类需要手动管理内存的编程语言中，将对象或者结构体分配到栈上或者堆上是由工程师自主决定的，这也为工程师的工作带来的挑战，如果工程师能够精准地为每一个变量分配合理的空间，那么整个程序的运行效率和内存使用效率一定是最高的，但是手动分配内存会导致如下的两个问题：

1. 不需要分配到堆上的对象分配到了堆上 — 浪费内存空间；
2. 需要分配到堆上的对象分配到了栈上 — 悬挂指针、影响内存安全；

与悬挂指针相比，浪费内存空间反而是小问题。在 C 语言中，栈上的变量被函数作为返回值返回给调用方是一个常见的错误，在如下所示的代码中，栈上的变量 `i` 被错误返回：

```c
int *dangling_pointer() {
    int i = 2;
    return &i;
}
```

C

当 `dangling_pointer` 函数返回后，它的本地变量会被编译器回收，调用方获取的是危险的悬挂指针，我们不确定当前指针指向的值是否合法时，这种问题在大型项目中是比较难以发现和定位的。

在编译器优化中，逃逸分析是用来决定指针动态作用域的方法[5](https://draven.co/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#fn:5)。Go 语言的编译器使用逃逸分析决定哪些变量应该在栈上分配，哪些变量应该在堆上分配，其中包括使用 `new`、`make` 和字面量等方法隐式分配的内存，Go 语言的逃逸分析遵循以下两个不变性：

1. 指向栈对象的指针不能存在于堆中；
2. 指向栈对象的指针不能在栈对象回收后存活；

![escape-analysis-and-key-invariants](栈内存管理.assets/2020-03-23-15849514795864-escape-analysis-and-key-invariants.png)

​											**图 7-44 逃逸分析和不变性**

我们通过上图展示两条不变性存在的意义，当我们违反了第一条不变性时，堆上的绿色指针指向了栈中的黄色内存，一旦函数返回后函数栈会被回收，该绿色指针指向的值就不再合法；如果我们违反了第二条不变性，因为寄存器 SP 下面的内存由于函数返回已经释放，所以黄色指针指向的内存已经不再合法。

逃逸分析是静态分析的一种，在编译器解析了 Go 语言源文件后，它可以获得整个程序的抽象语法树（Abstract syntax tree，AST），编译器可以根据抽象语法树分析静态的数据流，我们会通过以下几个步骤实现静态分析的全过程[6](https://draven.co/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#fn:6)：

1. 构建带权重的有向图，其中顶点 [`cmd/compile/internal/gc.EscLocation`](https://draven.co/golang/tree/cmd/compile/internal/gc.EscLocation) 表示被分配的变量，边 [`cmd/compile/internal/gc.EscEdge`](https://draven.co/golang/tree/cmd/compile/internal/gc.EscEdge) 表示变量之间的分配关系，权重表示寻址和取地址的次数；
2. 遍历对象分配图并查找违反两条不变性的变量分配关系，如果堆上的变量指向了栈上的变量，那么该变量需要分配在堆上；
3. 记录从函数的调用参数到堆以及返回值的数据流，增强函数参数的逃逸分析；

决定变量是在栈上还是堆上虽然重要，但是这是一个定义相对清晰的问题，我们可以通过编译器统一作决策。为了保证内存的绝对安全，编译器可能会将一些变量错误地分配到堆上，但是因为堆也会被垃圾收集器扫描，所以不会造成内存泄露以及悬挂指针等安全问题，解放了工程师的生产力。



#### 哪些情况下变量会发生逃逸

“返回引用闭包逃，接口地址 map 指针扰”